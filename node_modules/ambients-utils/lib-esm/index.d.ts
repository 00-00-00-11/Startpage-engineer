export declare type nil = null | undefined;
export declare type Obj<T> = {
    [key: string]: T;
};
export declare type ObjNotFn<T> = Obj<T> & {
    prototype?: never;
};
export declare type Callback<T> = (value: T) => void;
export declare type valueof<T> = T[keyof T];
export declare type valueofarray<T extends ArrayLike<any>> = T[number];
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type Optional<T, K extends keyof T> = Omit<T, K> & {
    [k in K]?: T[k];
};
declare const _global: typeof globalThis & Obj<any>;
export { _global as global };
export declare function forceGet<A, T, U extends T>(map: Map<A, T>, obj: A, factory: () => U): T;
export declare function forceGet<A extends object, T, U extends T>(map: WeakMap<A, T>, obj: A, factory: () => U): T;
export declare function move<T>(array: Array<T>, oldIndex: number, newIndex: number): Array<T>;
export declare function clear<T extends Array<any>>(array: T): T;
export declare function isEqual(a: any, b: any): boolean;
export declare function isObject<T = any>(arg: any): arg is Obj<T>;
export declare function isObjectNotFunction<T = any>(arg: any): arg is ObjNotFn<T>;
export declare function isString(arg: any): arg is string;
export declare function isNumber(arg: any): arg is number;
export declare function isBoolean(arg: any): arg is boolean;
export declare function isArray<T = any>(arg: any): arg is Array<T>;
export declare function isFunction(arg: any): arg is Function;
export declare function isDate(arg: any): arg is Date;
export declare function isQuote(value: string): boolean;
export declare function unquote(value: string): string;
export declare const numbers: Obj<boolean>;
export declare function canParseFloat(str: string): boolean;
export declare function parseFloatUnit(str: string): {
    num: number;
    unit: string;
};
export declare function parseDuration(val: string | number): number;
export declare function parseSize(val: string | number, percentRef: number): number;
export declare function unitize(val: string | number, unit: string): string;
export declare function cssPoint(left: string | number, top: string | number): string;
export declare function parentPath(path: string): string;
export declare function standardizePath(path: string): string;
export declare function between(source: string, a: string | number, b: string | number, start?: number): string;
export declare function replaceAll(str: string, search: string, replacement: string): string;
export declare function indexesOf(source: string, search: string): Array<number>;
export declare function indexesBefore(source: string, search: string, length: number): Array<number>;
export declare function extension(path: string): string;
export declare function kebabCase(str: string): string;
export declare function fastKebabCase(text: string): string;
export declare function camelCase(str: string): string;
export declare function fastCamelCase(text: string): string;
export declare function upperFirst(str: string): string;
export declare function lowerFirst(str: string): string;
export declare function extend<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U>;
export declare function extendNull<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U>;
export declare function mergeArrays<A, T>(dst: Array<A | T>, src: Array<T>): Array<A | T>;
export declare function mergeArraysNull<A, T>(dst: Array<A | T>, src: Array<T>): Array<A | T>;
export declare function merge<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U>;
export declare function mergeNull<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U>;
export declare function cloneDeep<T extends Obj<any> | Array<any>>(src: T): T;
export declare function someOwn<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => any): boolean;
export declare function forOwn<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => void): void;
export declare function forOwnDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string, owner: Obj<any>) => void): void;
export declare function reduce<T, P extends Obj<any>>(o: P, cb: (r: T, v: valueof<P>, k: string) => T, initial: T): T;
export declare function omit(o: Obj<any>, key: string): Obj<any>;
export declare function omit(o: Obj<any>, keys: Array<string>): Obj<any>;
export declare function omitDeep(o: Obj<any>, key: string): Obj<any>;
export declare function omitDeep(o: Obj<any>, keys: Array<string>): Obj<any>;
export declare function replaceKeys<T extends Obj<any>>(o: T, map: Obj<string>): Obj<any>;
export declare function replaceKeysDeep<T extends Obj<any>>(o: T, map: Obj<string>): Obj<any>;
export declare function mapValues<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => valueof<T>): T;
export declare function mapValuesDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => valueof<T>): Obj<any>;
export declare function mapKeys<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => string): Obj<any>;
export declare function mapKeysDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => string): Obj<any>;
export declare function filterKeys<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => boolean): Array<string>;
export declare function filterKeysDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => boolean): Array<string>;
export declare function sortByKeys<T>(o: Obj<T>, order: Array<string>): Obj<T>;
export declare function reverse<T>(o: Obj<T>): Obj<T>;
export declare function pickBy<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => any): Obj<any>;
export declare function values<T>(o: Obj<T>): Array<T>;
export declare function size(o: Obj<any>): number;
export declare function entries<T>(o: Obj<T>): Array<[string, T]>;
export declare function fromPairs<T>(array: Array<[string, T]>): Obj<T>;
export declare function forEach<T>(array: ArrayLike<T>, cb: (item: T, index: number) => void): void;
export declare function pushOne<T>(array: Array<T>, item: T): boolean;
export declare function pullOne<T>(array: Array<T>, item: T): boolean;
export declare function pullOneBy<T>(array: Array<T>, predicate: (val: T) => boolean): boolean;
export declare function last<T>(array: ArrayLike<T>, count?: number): T | undefined;
export declare function last<T>(array: ArrayLike<T>, count: number, defaultVal: T): T;
export declare class ArraySet<T extends object> {
    private array;
    private set;
    constructor(array: Array<T>);
    add(val: T): void;
    delete(val: T): void;
    clear(): void;
    has(val: T): boolean;
}
export declare function defaultTo<T>(val: T, defaultVal: T): T;
export declare function coalesce<T>(items: Array<T>): T;
export declare function get<T = any>(item: any, path: string): T | undefined;
export declare function get<T = any>(item: any, path: string, defaultVal: T): T;
export declare function call(item: any, path: string, args: Array<any>, force?: boolean): any;
export declare function now(): number;
export declare function hours(beginTime?: string, endTime?: string, division?: number): string[];
export declare function range(end: number): Array<number>;
export declare function range(start: number, end: number, step?: number): Array<number>;
export declare function randomColor(): string;
export declare function concatOne(src: string | nil, str: string, prepend?: boolean, delimiter?: string): string;
export declare function splitOutside(val: string, delimiter: string, leftSymbol: string, rightSymbol: string): string[];
export declare function random(min: number, max: number): number;
export declare function leadingDebounce<T extends Function>(cb: T, promiseFactory: () => Promise<any>): T;
export declare function leadingDebounce<T extends Function>(cb: T, duration?: number): T;
export declare function mergeFunctions<T extends Function | nil>(dst: T, src: Exclude<T, nil>): T;
export declare function log(...args: Array<any>): void;
export declare class Queue implements PromiseLike<void> {
    private resolvables;
    then(cb: Callback<void>): this;
    then(cb: Callback<void>): this;
    resolve(): this;
}
declare abstract class Thenable<T> implements PromiseLike<T> {
    protected _done: boolean;
    private _value;
    private _callbacks;
    private _watched;
    private _cb;
    constructor(cb?: Callback<T>);
    then(cb: Callback<T>): Cancellable;
    then(cb: Callback<T>): Cancellable;
    watch<U extends Thenable<any>>(item: U): U;
    protected _resolve(val: T): this;
}
export declare class Resolvable<T = void> extends Thenable<T> {
    constructor(cb?: Callback<T>);
    readonly resolved: boolean;
    resolve(val: T): this;
}
export declare class Cancellable<T = void> extends Thenable<T> {
    constructor(cb?: Callback<T>);
    readonly cancelled: boolean;
    cancel(val: T): this;
}
export declare class Playable<T = void> extends Thenable<T> {
    paused: boolean;
    constructor(autoplay?: boolean);
    readonly stopped: boolean;
    stop(val: T): this;
    private pauseCbs;
    private playCbs;
    onPause(cb: Callback<void>): Cancellable;
    onPlay(cb: Callback<void>): Cancellable;
    pause(): this;
    play(): this;
}
export declare class Destroyable<T = void> extends Thenable<T> {
    constructor(cb?: Callback<T>);
    readonly destroyed: boolean;
    destroy(val: T): this;
}
export declare class Value<T = any> extends Destroyable {
    private cbs;
    private state;
    private hasState;
    constructor(value?: T);
    on(cb: Callback<T>): Cancellable;
    once(cb: Callback<T>): Cancellable;
    set(value: T): this;
}
export declare class Events<T = any, U extends string = any> extends Destroyable {
    private cbsMap;
    private states;
    constructor();
    on(name: U | Array<U>, cb: Callback<T>): Cancellable;
    once(name: U | Array<U>, cb: Callback<T>): Cancellable;
    emit(name: U, value: T): void;
    hasState(name: U): boolean;
    setState(name: U, value: T): void;
    getState(name: U): T | undefined;
    deleteState(name: U): void;
    interval(cb: Callback<any>, delay: number): Cancellable;
    timeout(cb: Callback<any>, delay: number): Cancellable;
    nextFrame(cb: Callback<any>): Cancellable;
    nextTick(cb: Callback<any>): Cancellable;
    endOfTick(cb: Callback<any>): Cancellable;
    nextDelay(cb: Callback<any>): Cancellable;
    nthDelay(cb: Callback<any>, n: number): Cancellable;
    frameLoop(cb: (deltaTime: number, time: number) => void): Cancellable;
}
export declare class DomEvents extends Events {
    private el;
    private listening;
    constructor(el: Node, name?: string | Array<string>);
    listen(name: string | Array<string>): this;
}
export declare function interval(cb: Callback<any>, delay: number): Cancellable;
export declare function timeout(cb: Callback<any>, delay: number): Cancellable;
export declare function nextFrame(cb: Callback<any>): Cancellable;
export declare function nextTick(cb: Callback<any>): Cancellable;
export declare function endOfTick(cb: Callback<any>): Cancellable;
export declare function nextDelay(cb: Callback<any>): Cancellable;
export declare function nthDelay(cb: Callback<any>, n: number): Cancellable;
export declare function frameLoop(cb: (deltaTime: number, time: number) => void): Cancellable;
export declare function drawDiv(left: number, top: number, parent?: Node): HTMLElement;
export declare function loadImage(src: string | HTMLImageElement): Promise<HTMLImageElement>;
export declare function naturalSize(image: HTMLImageElement): Promise<{
    width: number;
    height: number;
}>;
export declare function clientSize(el: Node): Promise<{
    width: number;
    height: number;
}>;
export declare function remove<T extends Node>(el: T): T;
export declare function addClass<T extends Node>(el: T, name: string, prepend?: boolean): T;
export declare function html<T extends HTMLElement>(html: string): T;
export declare function vif<T>(bool: boolean, res: T): T | undefined;
