//@ts-ignore
const _global = typeof globalThis === "object" ? globalThis : global;
export { _global as global };
export function forceGet(map, obj, factory) {
    if (!map.has(obj)) {
        const item = factory();
        map.set(obj, item);
        return item;
    }
    return map.get(obj);
}
export function move(array, oldIndex, newIndex) {
    const result = [];
    for (let i = 0; i < array.length; ++i) {
        if (i === newIndex)
            result.push(array[oldIndex]);
        if (i !== oldIndex)
            result.push(array[i]);
    }
    return result;
}
export function clear(array) {
    array.splice(0, array.length);
    return array;
}
export function isEqual(a, b) {
    if (a === b)
        return true;
    return JSON.stringify(a) === JSON.stringify(b);
}
export function isObject(arg) {
    return arg != null && arg.constructor === Object;
}
export function isObjectNotFunction(arg) {
    return arg != null && arg.constructor === Object;
}
export function isString(arg) {
    return arg != null && arg.constructor === String;
}
export function isNumber(arg) {
    return arg != null && arg.constructor === Number;
}
export function isBoolean(arg) {
    return arg != null && arg.constructor === Boolean;
}
export function isArray(arg) {
    return arg != null && arg.constructor === Array;
}
export function isFunction(arg) {
    return typeof arg === "function";
}
export function isDate(arg) {
    return arg != null && arg.constructor === Date;
}
export function isQuote(value) {
    return value === '"' || value === "'";
}
export function unquote(value) {
    if (value[0] === '"' || value[0] === "'")
        return value.slice(1, -1);
    return value;
}
export const numbers = {
    1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: true, 0: true
};
const numbersEx = { ...numbers, "+": true, "-": true };
export function canParseFloat(str) {
    const char = str[0];
    if (char === "+" || char === "-" || char === ".")
        return numbers[str[1]] === true;
    return numbers[char] === true;
}
export function parseFloatUnit(str) {
    let numStr = "", unitStr = "", isNum = true;
    for (const char of str) {
        if (isNum && numbersEx[char] !== true)
            isNum = false;
        if (isNum)
            numStr += char;
        else
            unitStr += char;
    }
    return { num: parseFloat(numStr), unit: unitStr };
}
export function parseDuration(val) {
    if (isNumber(val))
        return val;
    const { num, unit } = parseFloatUnit(val);
    if (unit === "s")
        return num * 1000;
    return num;
}
export function parseSize(val, percentRef) {
    if (isNumber(val))
        return val;
    const lastChar = val[val.length - 1];
    if (lastChar === "%")
        return parseFloat(val) / 100 * percentRef;
    return parseFloat(val);
}
export function unitize(val, unit) {
    if (isString(val))
        return val;
    return val + unit;
}
export function cssPoint(left, top) {
    return unitize(left, "px") + " " + unitize(top, "px");
}
export function parentPath(path) {
    if (path[path.length - 1] === "/")
        path = path.slice(0, -1);
    const parts = path.split("/");
    parts.pop();
    return parts.join("/");
}
export function standardizePath(path) {
    path = path.trim().replace("\\", "/").replace(/([^:]\/)\/+/g, "$1");
    if (path.includes("file:///"))
        path = path.replace("file://", "file:///");
    if (path[path.length - 1] === "/")
        path = path.slice(0, -1);
    return path;
}
export function between(source, a, b, start = 0) {
    let iA = -1;
    if (isNumber(a))
        iA = a;
    else {
        iA = source.indexOf(a, start);
        if (iA !== -1)
            iA += a.length - 1;
    }
    if (iA === -1)
        return "";
    const iB = isNumber(b) ? b : source.indexOf(b, iA);
    if (iB === -1)
        return "";
    return source.substring(a.constructor === Number ? iA : iA + 1, iB);
}
export function replaceAll(str, search, replacement) {
    return str.split(search).join(replacement);
}
export function indexesOf(source, search) {
    const a = [];
    let i = -1;
    while ((i = source.indexOf(search, i + 1)) >= 0)
        a.push(i);
    return a;
}
export function indexesBefore(source, search, length) {
    const result = [], firstChar = search[0];
    let lastPos = 0;
    for (let i = 0; i < source.length; ++i) {
        if (i - lastPos >= length)
            break;
        if (source[i] !== firstChar)
            continue;
        let count = 0, found = true;
        const jMax = search.length + i;
        for (let j = i; j < jMax; ++j) {
            if (source[j] !== search[count]) {
                found = false;
                break;
            }
            ++count;
        }
        if (found)
            result.push(i), lastPos = i;
    }
    return result;
}
export function extension(path) {
    const parts = path.split(".");
    if (parts.length > 1)
        return parts.pop().toLowerCase();
    return "";
}
export function kebabCase(str) {
    let result = "", isNumOld = false;
    for (const char of str) {
        const isNum = numbers[char] === true;
        const lower = char.toLowerCase();
        if (char !== lower) {
            if (result !== "")
                result += "-" + lower;
            else
                result = lower;
        }
        else if (isNum !== isNumOld)
            result += "-" + lower;
        else
            result += char;
        isNumOld = isNum;
    }
    return result;
}
const kebabed = new Map();
export function fastKebabCase(text) {
    return forceGet(kebabed, text, () => kebabCase(text));
}
export function camelCase(str) {
    str = str.replace(/[-_\s]+(.)?/g, (match, ch) => (ch ? ch.toUpperCase() : ""));
    return str.substr(0, 1).toLowerCase() + str.substr(1);
}
const cameled = new Map();
export function fastCamelCase(text) {
    return forceGet(cameled, text, () => camelCase(text));
}
export function upperFirst(str) {
    return str[0].toUpperCase() + str.slice(1);
}
export function lowerFirst(str) {
    return str[0].toLowerCase() + str.slice(1);
}
export function extend(dst, src) {
    for (const key of Object.keys(src))
        dst[key] = src[key];
    return dst;
}
export function extendNull(dst, src) {
    for (const key of Object.keys(src))
        if (dst[key] == null)
            dst[key] = src[key];
    return dst;
}
export function mergeArrays(dst, src) {
    let max, min;
    if (src.length > dst.length)
        max = src, min = dst;
    else
        max = dst, min = src;
    for (let key = 0; key < min.length; ++key) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject(srcVal) && isObject(dstVal))
            merge(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal))
            mergeArrays(dstVal, srcVal);
        else
            dst[key] = srcVal;
    }
    for (let i = min.length; i < max.length; ++i)
        dst[i] = max[i];
    return dst;
}
export function mergeArraysNull(dst, src) {
    let max, min;
    if (src.length > dst.length)
        max = src, min = dst;
    else
        max = dst, min = src;
    for (let key = 0; key < min.length; ++key) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject(srcVal) && isObject(dstVal))
            mergeNull(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal))
            mergeArraysNull(dstVal, srcVal);
        else if (dstVal == null)
            dst[key] = srcVal;
    }
    for (let i = min.length; i < max.length; ++i)
        dst[i] = max[i];
    return dst;
}
export function merge(dst, src) {
    for (const key of Object.keys(src)) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject(srcVal) && isObject(dstVal))
            merge(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal))
            mergeArrays(dstVal, srcVal);
        else
            dst[key] = srcVal;
    }
    return dst;
}
export function mergeNull(dst, src) {
    for (const key of Object.keys(src)) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject(srcVal) && isObject(dstVal))
            mergeNull(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal))
            mergeArraysNull(dstVal, srcVal);
        else if (dstVal == null)
            dst[key] = srcVal;
    }
    return dst;
}
export function cloneDeep(src) {
    if (isObjectNotFunction(src)) {
        const r = {};
        forOwn(src, (v, k) => r[k] = cloneDeep(v));
        return r;
    }
    if (isArray(src)) {
        const length = src.length;
        const r = new Array(length);
        for (let i = 0; i < length; ++i)
            r[i] = cloneDeep(src[i]);
        return r;
    }
    return src;
}
export function someOwn(o, cb) {
    for (const key of Object.keys(o))
        if (cb(o[key], key))
            return true;
    return false;
}
export function forOwn(o, cb) {
    for (const key of Object.keys(o))
        cb(o[key], key);
}
export function forOwnDeep(o, cb) {
    forOwn(o, (value, key) => {
        if (isObject(value))
            forOwnDeep(value, cb);
        cb(value, key, o);
    });
}
export function reduce(o, cb, initial) {
    let res = initial;
    forOwn(o, (v, k) => res = cb(res, v, k));
    return res;
}
export function omit(o, arg1) {
    if (isArray(arg1))
        return reduce(o, (r, v, k) => {
            if (!arg1.includes(k))
                r[k] = v;
            return r;
        }, {});
    return reduce(o, (r, v, k) => {
        if (k !== arg1)
            r[k] = v;
        return r;
    }, {});
}
export function omitDeep(o, arg1) {
    if (isArray(arg1))
        return reduce(o, (r, v, k) => {
            if (!arg1.includes(k))
                r[k] = isObject(v) ? omitDeep(v, arg1) : v;
            return r;
        }, {});
    return reduce(o, (r, v, k) => {
        if (k !== arg1)
            r[k] = isObject(v) ? omitDeep(v, arg1) : v;
        return r;
    }, {});
}
export function replaceKeys(o, map) {
    return reduce(o, (r, v, k) => {
        r[map[k] || k] = v;
        return r;
    }, {});
}
export function replaceKeysDeep(o, map) {
    return reduce(o, (r, v, k) => {
        r[map[k] || k] = isObject(v) ? replaceKeysDeep(v, map) : v;
        return r;
    }, {});
}
export function mapValues(o, cb) {
    return reduce(o, (r, v, k) => {
        r[k] = cb(v, k);
        return r;
    }, {});
}
export function mapValuesDeep(o, cb) {
    return reduce(o, (r, v, k) => {
        //@ts-ignore
        r[k] = cb(isObject(v) ? mapValuesDeep(v, cb) : v, k);
        return r;
    }, {});
}
export function mapKeys(o, cb) {
    return reduce(o, (r, v, k) => {
        r[cb(v, k)] = v;
        return r;
    }, {});
}
export function mapKeysDeep(o, cb) {
    return reduce(o, (r, v, k) => {
        r[cb(v, k)] = isObject(v) ? mapKeysDeep(v, cb) : v;
        return r;
    }, {});
}
export function filterKeys(o, cb) {
    return reduce(o, (r, v, k) => {
        if (cb(v, k))
            r.push(k);
        return r;
    }, []);
}
export function filterKeysDeep(o, cb) {
    return reduce(o, (r, v, k) => {
        if (isObject(v))
            for (const _k of filterKeysDeep(v, cb))
                r.push(_k);
        if (cb(v, k))
            r.push(k);
        return r;
    }, []);
}
export function sortByKeys(o, order) {
    const r = {};
    for (const k of order) {
        if (k in o)
            r[k] = o[k];
    }
    return extendNull(r, o);
}
export function reverse(o) {
    return sortByKeys(o, Object.keys(o).reverse());
}
export function pickBy(o, cb) {
    const result = {};
    forOwn(o, (v, k) => { if (cb(v, k))
        result[k] = v; });
    return result;
}
export function values(o) {
    const result = [];
    forOwn(o, v => result.push(v));
    return result;
}
export function size(o) {
    return Object.keys(o).length;
}
export function entries(o) {
    const result = [];
    forOwn(o, (v, k) => result.push([k, v]));
    return result;
}
export function fromPairs(array) {
    const result = {};
    for (const pair of array)
        result[pair[0]] = pair[1];
    return result;
}
export function forEach(array, cb) {
    const a = new Array(array.length);
    for (let i = 0; i < array.length; ++i)
        a[i] = array[i];
    for (let i = 0; i < a.length; ++i)
        cb(a[i], i);
}
export function pushOne(array, item) {
    if (array.includes(item))
        return false;
    array.push(item);
    return true;
}
export function pullOne(array, item) {
    const index = array.indexOf(item);
    if (index === -1)
        return false;
    array.splice(index, 1);
    return true;
}
export function pullOneBy(array, predicate) {
    for (const item of array)
        if (predicate(item)) {
            pullOne(array, item);
            return true;
        }
    return false;
}
export function last(array, count = 0, defaultVal) {
    const index = array.length - (count + 1);
    if (index < 0) {
        if (defaultVal != null)
            return defaultVal;
        else
            return array[0];
    }
    return array[index];
}
const arraySetMap = new WeakMap();
export class ArraySet {
    constructor(array) {
        if (arraySetMap.has(array))
            this.set = arraySetMap.get(array);
        else {
            this.set = new WeakSet();
            arraySetMap.set(array, this.set);
            for (const item of array)
                this.set.add(item);
        }
        this.array = array;
    }
    add(val) {
        if (this.set.has(val))
            return;
        this.set.add(val);
        this.array.push(val);
    }
    delete(val) {
        if (!this.set.has(val))
            return;
        this.set.delete(val);
        pullOne(this.array, val);
    }
    clear() {
        for (const item of this.array)
            this.set.delete(item);
        clear(this.array);
    }
    has(val) {
        return this.set.has(val);
    }
}
export function defaultTo(val, defaultVal) {
    if (!val && val !== "" && val !== 0)
        return defaultVal;
    else
        return val;
}
//@ts-ignore
export function coalesce(items) {
    for (const i of items)
        if (i != null)
            return i;
}
export function get(item, path, defaultVal) {
    for (const part of path.split(".")) {
        item = item[part];
        if (item == null)
            return defaultVal;
    }
    return item;
}
export function call(item, path, args, force = false) {
    let parent;
    for (const part of path.split(".")) {
        parent = item;
        item = item[part];
        if (item == null) {
            if (!force)
                return;
            throw new Error('invalid function');
        }
    }
    if (!isFunction(item)) {
        if (!force)
            return;
        throw new Error('invalid function');
    }
    return item.apply(parent, args);
}
export function now() {
    return (new Date()).getTime();
}
function time2Step(timeStr, stepSize) {
    const parts = timeStr.split(":"), minutesStr = parts[1], hoursStr = parts[0];
    const minutes = parseFloat(minutesStr), hours = parseFloat(hoursStr);
    const totalHours = hours + (minutes / 60), totalMinutes = totalHours * 60;
    return totalMinutes / stepSize;
}
export function hours(beginTime = "00:00", endTime = "23:59", division = 2) {
    const stepSize = 60 / division, stepCount = 24 * division;
    const beginStep = time2Step(beginTime, stepSize), endStep = time2Step(endTime, stepSize);
    const result = [];
    for (let step = 0; step <= stepCount; ++step) {
        if (step < beginStep || step > endStep)
            continue;
        const totalMinutes = step * stepSize, totalHours = totalMinutes / 60;
        const hours = Math.floor(totalHours), minutes = Math.floor((totalHours - hours) * 60);
        let hoursStr = "" + hours;
        if (hoursStr.length === 1)
            hoursStr = "0" + hoursStr;
        let minutesStr = "" + minutes;
        if (minutesStr.length === 1)
            minutesStr = "0" + minutesStr;
        result.push(hoursStr + ":" + minutesStr);
    }
    return result;
}
export function range(start, end, step = 1) {
    step = Math.abs(step);
    if (end == null) {
        end = start;
        start = 0;
    }
    const r = [];
    if (end >= start)
        for (let i = start; i < end; i += step)
            r.push(i);
    else
        for (let i = start; i > end; i -= step)
            r.push(i);
    return r;
}
export function randomColor() {
    const letters = "0123456789ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; ++i)
        color += letters[Math.floor(Math.random() * 16)];
    return color;
}
export function concatOne(src, str, prepend = false, delimiter = " ") {
    if (!src)
        return str;
    const parts = src.split(delimiter);
    if (parts.includes(str))
        return src;
    prepend ? parts.unshift(str) : parts.push(str);
    return parts.join(delimiter);
}
export function splitOutside(val, delimiter, leftSymbol, rightSymbol) {
    const tmp = val.split(delimiter);
    const result = [];
    for (let i = 0, j = 0; i < tmp.length; ++i) {
        result[j] = (result[j] != null ? result[j] + delimiter : "") + tmp[i];
        if (!result[j].includes(leftSymbol) || result[j].includes(rightSymbol))
            j++;
    }
    return result;
}
export function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
export function leadingDebounce(cb, arg1 = 0) {
    let blocked = false, result;
    return function () {
        if (blocked)
            return result;
        blocked = true, result = cb.apply(this, arguments);
        if (isNumber(arg1))
            setTimeout(() => blocked = false, arg1);
        else
            arg1().then(() => blocked = false);
        return result;
    };
}
export function mergeFunctions(dst, src) {
    if (dst == null)
        return src;
    return function () {
        src.apply(this, arguments);
        return dst.apply(this, arguments);
    };
}
function clearProto(o) {
    const obj = JSON.parse(JSON.stringify(o));
    if (obj && typeof obj === "object") {
        obj.__proto__ = null;
        for (const j in obj)
            obj[j] = clearProto(obj[j]);
    }
    return obj;
}
export function log(...args) {
    for (let i = 0; i < args.length; ++i)
        args[i] = clearProto(args[i]);
    console.log(...args);
}
export class Queue {
    constructor() {
        this.resolvables = [new Resolvable().resolve()];
    }
    then(cb) {
        this.resolvables[this.resolvables.length - 1].then(cb);
        const r = new Resolvable(() => { pullOne(this.resolvables, r); });
        this.resolvables.push(r);
        return this;
    }
    resolve() {
        if (this.resolvables.length === 1)
            return this;
        this.resolvables[1].resolve();
        return this;
    }
}
class Thenable {
    constructor(cb) {
        this._done = false;
        this._value = null;
        this._callbacks = [];
        this._watched = [];
        this._cb = null;
        if (cb != null)
            this._cb = cb;
    }
    then(cb) {
        if (this._done) {
            if (this._value === null)
                throw new Error("unexpected value");
            cb(this._value);
            return new Cancellable();
        }
        else {
            this._callbacks.push(cb);
            return new Cancellable(() => pullOne(this._callbacks, cb));
        }
    }
    watch(item) {
        if (this._done)
            return item._resolve(this._value);
        this._watched.push(item);
        item.then(() => pullOne(this._watched, item));
        return item;
    }
    _resolve(val) {
        if (this._done)
            return this;
        this._done = true;
        this._value = val;
        if (this._cb != null)
            this._cb(val);
        this._cb = null;
        for (const cb of [...this._callbacks])
            cb(val);
        this._callbacks = [];
        for (const item of [...this._watched])
            item._resolve(val);
        this._watched = [];
        return this;
    }
}
export class Resolvable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    get resolved() {
        return this._done;
    }
    resolve(val) {
        return this._resolve(val);
    }
}
export class Cancellable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    get cancelled() {
        return this._done;
    }
    cancel(val) {
        return super._resolve(val);
    }
}
export class Playable extends Thenable {
    constructor(autoplay = false) {
        super();
        this.paused = true;
        this.pauseCbs = [];
        this.playCbs = [];
        if (autoplay)
            this.paused = false;
    }
    get stopped() {
        return this._done;
    }
    stop(val) {
        return super._resolve(val);
    }
    onPause(cb) {
        if (this._done)
            return new Cancellable();
        if (this.paused)
            cb();
        this.pauseCbs.push(cb);
        return new Cancellable(() => pullOne(this.pauseCbs, cb));
    }
    onPlay(cb) {
        if (this._done)
            return new Cancellable();
        if (!this.paused)
            cb();
        this.playCbs.push(cb);
        return new Cancellable(() => pullOne(this.playCbs, cb));
    }
    pause() {
        if (this._done || this.paused)
            return this;
        this.paused = true;
        for (const cb of this.pauseCbs)
            cb();
        return this;
    }
    play() {
        if (this._done || !this.paused)
            return this;
        this.paused = false;
        for (const cb of this.playCbs)
            cb();
        return this;
    }
}
export class Destroyable extends Thenable {
    constructor(cb) {
        super(cb);
    }
    get destroyed() {
        return this._done;
    }
    destroy(val) {
        return super._resolve(val);
    }
}
export class Value extends Destroyable {
    constructor(value) {
        super(() => {
            this.cbs = [];
            //@ts-ignore
            this.state = undefined;
            this.hasState = false;
        });
        this.cbs = [];
        this.hasState = false;
        if (value != null)
            this.set(value);
    }
    on(cb) {
        if (this.hasState)
            cb(this.state);
        this.cbs.push(cb);
        return new Cancellable(() => pullOne(this.cbs, cb));
    }
    once(cb) {
        let done = false;
        const handle = this.on(value => {
            if (done)
                return;
            done = true;
            cb(value);
            setTimeout(() => handle.cancel(), 0);
        });
        return handle;
    }
    set(value) {
        if (value === this.state)
            return this;
        this.state = value;
        this.hasState = true;
        for (const cb of this.cbs)
            cb(value);
        return this;
    }
}
export class Events extends Destroyable {
    constructor() {
        super(() => {
            this.cbsMap.clear();
            this.states.clear();
        });
        this.cbsMap = new Map();
        this.states = new Map();
    }
    on(name, cb) {
        if (isArray(name)) {
            const handle = new Cancellable();
            for (const n of name)
                handle.watch(this.on(n, cb));
            return handle;
        }
        if (this.states.has(name))
            cb(this.states.get(name));
        const cbs = forceGet(this.cbsMap, name, () => []);
        cbs.push(cb);
        return new Cancellable(() => pullOne(cbs, cb));
    }
    once(name, cb) {
        let done = false;
        const handle = this.on(name, value => {
            if (done)
                return;
            done = true;
            cb(value);
            setTimeout(() => handle.cancel(), 0);
        });
        return handle;
    }
    emit(name, value) {
        const cbs = this.cbsMap.get(name);
        if (cbs != null)
            for (const cb of cbs)
                cb(value);
    }
    hasState(name) {
        return this.states.has(name);
    }
    setState(name, value) {
        this.states.set(name, value);
        this.emit(name, value);
    }
    getState(name) {
        return this.states.get(name);
    }
    deleteState(name) {
        this.states.delete(name);
    }
    interval(cb, delay) {
        return this.watch(interval(cb, delay));
    }
    timeout(cb, delay) {
        return this.watch(timeout(cb, delay));
    }
    nextFrame(cb) {
        return this.watch(nextFrame(cb));
    }
    nextTick(cb) {
        return this.watch(nextTick(cb));
    }
    endOfTick(cb) {
        return this.watch(endOfTick(cb));
    }
    nextDelay(cb) {
        return this.watch(nextDelay(cb));
    }
    nthDelay(cb, n) {
        return this.watch(nthDelay(cb, n));
    }
    frameLoop(cb) {
        return this.watch(frameLoop(cb));
    }
}
export class DomEvents extends Events {
    constructor(el, name) {
        super();
        this.listening = new Set();
        this.el = el;
        if (name != null)
            this.listen(name);
    }
    listen(name) {
        if (isArray(name)) {
            for (const n of name)
                this.listen(n);
            return this;
        }
        if (this.listening.has(name))
            return this;
        this.listening.add(name);
        const cb = (e) => this.emit(name, e);
        this.el.addEventListener(name, cb);
        this.then(() => this.el.removeEventListener(name, cb));
        return this;
    }
}
export function interval(cb, delay) {
    const interval = setInterval(cb, delay);
    return new Cancellable(() => clearInterval(interval));
}
export function timeout(cb, delay) {
    const timeout = setTimeout(cb, delay);
    return new Cancellable(() => clearTimeout(timeout));
}
export function nextFrame(cb) {
    const handle = new Cancellable();
    requestAnimationFrame(() => {
        //@ts-ignore
        if (!handle.cancelled)
            cb();
    });
    return handle;
}
export function nextTick(cb) {
    return timeout(cb, 0);
}
export function endOfTick(cb) {
    const handle = new Cancellable();
    Promise.resolve().then(() => {
        //@ts-ignore
        if (!handle.cancelled)
            cb();
    });
    return handle;
}
export function nextDelay(cb) {
    const handle = new Cancellable();
    setTimeout(() => requestAnimationFrame(() => requestAnimationFrame(() => {
        //@ts-ignore
        if (!handle.cancelled)
            cb();
    })), 0);
    return handle;
}
export function nthDelay(cb, n) {
    const handle = new Cancellable();
    (async () => {
        for (let i = 0; i < n; ++i) {
            await new Promise(r => nextDelay(r));
            if (handle.cancelled)
                return;
        }
        //@ts-ignore
        cb();
    })();
    return handle;
}
export function frameLoop(cb) {
    const handle = new Cancellable();
    let start = -1;
    function fn(time) {
        if (handle.cancelled)
            return;
        if (start === -1)
            start = time;
        cb(time - start, time);
        requestAnimationFrame(fn);
    }
    ;
    requestAnimationFrame(fn);
    return handle;
}
export function drawDiv(left, top, parent = document.body) {
    const v = parent.appendChild(document.createElement("div"));
    v.style.transform = "translateX(-50%) translateY(-50%)";
    v.style.width = "5px";
    v.style.height = "5px";
    v.style.background = randomColor();
    v.style.position = "absolute";
    v.style.left = left + "px";
    v.style.top = top + "px";
    v.style.zIndex = "9999";
    return v;
}
export function loadImage(src) {
    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        if (isString(src))
            img.src = src;
        else
            img.src = src.src;
    });
}
export function naturalSize(image) {
    return new Promise(resolve => {
        if (image.naturalWidth && image.naturalHeight) {
            resolve({ width: image.naturalWidth, height: image.naturalHeight });
            return;
        }
        const handle = interval(() => {
            if (!document.body.contains(image)) {
                handle.cancel();
                return;
            }
            if (!(image.naturalWidth && image.naturalHeight))
                return;
            handle.cancel();
            resolve({ width: image.naturalWidth, height: image.naturalHeight });
        }, 0);
    });
}
export function clientSize(el) {
    return new Promise(resolve => {
        if (el.clientWidth && el.clientHeight) {
            resolve({ width: el.clientWidth, height: el.clientHeight });
            return;
        }
        const handle = interval(() => {
            if (!document.body.contains(el)) {
                handle.cancel();
                return;
            }
            if (!(el.clientWidth && el.clientHeight))
                return;
            handle.cancel();
            resolve({ width: el.clientWidth, height: el.clientHeight });
        }, 0);
    });
}
export function remove(el) {
    if (el.parentElement != null)
        el.parentElement.removeChild(el);
    return el;
}
export function addClass(el, name, prepend = false) {
    el.className = concatOne(el.className, name, prepend);
    return el;
}
let htmlDiv;
export function html(html) {
    if (htmlDiv == null)
        htmlDiv = document.createElement("div");
    htmlDiv.innerHTML = html;
    const res = htmlDiv.firstElementChild;
    if (res == null)
        throw new Error("invalid html");
    return res;
}
export function vif(bool, res) {
    return bool ? res : undefined;
}
