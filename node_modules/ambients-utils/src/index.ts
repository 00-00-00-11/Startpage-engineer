export type nil = null | undefined;
export type Obj<T> = { [key: string]: T };
export type ObjNotFn<T> = Obj<T> & { prototype?: never }
export type Callback<T> = (value: T) => void;
export type valueof<T> = T[keyof T];
export type valueofarray<T extends ArrayLike<any>> = T[number];
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type Optional<T, K extends keyof T> = Omit<T, K> & { [k in K]?: T[k] };

//@ts-ignore
const _global: typeof globalThis & Obj<any> = typeof globalThis === "object" ? globalThis : global;
export { _global as global };

export function forceGet<A, T, U extends T>(map: Map<A, T>, obj: A, factory: () => U): T;
export function forceGet<A extends object, T, U extends T>(map: WeakMap<A, T>, obj: A, factory: () => U): T;
export function forceGet(map: Map<any, any> | WeakMap<any, any>, obj: any, factory: () => any): any {
    if (!map.has(obj)) {
        const item = factory();
        map.set(obj, item);
        return item;
    }
    return map.get(obj);
}

export function move<T>(array: Array<T>, oldIndex: number, newIndex: number): Array<T> {
    const result = [];
    for (let i = 0; i < array.length; ++i) {
        if (i === newIndex) result.push(array[oldIndex]);
        if (i !== oldIndex) result.push(array[i]);
    }
    return result;
}

export function clear<T extends Array<any>>(array: T): T {
    array.splice(0, array.length);
    return array;
}

export function isEqual(a: any, b: any): boolean {
    if (a === b) return true;
    return JSON.stringify(a) === JSON.stringify(b);
}

export function isObject<T = any>(arg: any): arg is Obj<T> {
    return arg != null && arg.constructor === Object;
}

export function isObjectNotFunction<T = any>(arg: any): arg is ObjNotFn<T> {
    return arg != null && arg.constructor === Object;
}

export function isString(arg: any): arg is string {
    return arg != null && arg.constructor === String;
}

export function isNumber(arg: any): arg is number {
    return arg != null && arg.constructor === Number;
}

export function isBoolean(arg: any): arg is boolean {
    return arg != null && arg.constructor === Boolean;
}

export function isArray<T = any>(arg: any): arg is Array<T> {
    return arg != null && arg.constructor === Array;
}

export function isFunction(arg: any): arg is Function {
    return typeof arg === "function";
}

export function isDate(arg: any): arg is Date {
    return arg != null && arg.constructor === Date;
}

export function isQuote(value: string): boolean {
    return value === '"' || value === "'";
}

export function unquote(value: string): string {
    if (value[0] === '"' || value[0] === "'") return value.slice(1, -1);
    return value;
}

export const numbers: Obj<boolean> = {
    1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: true, 0: true
}
const numbersEx: Obj<boolean> = { ...numbers, "+": true, "-": true };

export function canParseFloat(str: string): boolean {
    const char = str[0];
    if (char === "+" || char === "-" || char === ".") return numbers[str[1]] === true;
    return numbers[char] === true;
}

export function parseFloatUnit(str: string) {
    let numStr = "", unitStr = "", isNum = true;
    for (const char of str) {
        if (isNum && numbersEx[char] !== true) isNum = false;
        if (isNum) numStr += char; else unitStr += char;
    }
    return { num: parseFloat(numStr), unit: unitStr };
}

export function parseDuration(val: string | number): number {
    if (isNumber(val)) return val;
    const { num, unit } = parseFloatUnit(val);
    if (unit === "s") return num * 1000;
    return num;
}

export function parseSize(val: string | number, percentRef: number) {
    if (isNumber(val)) return val;

    const lastChar = val[val.length - 1];
    if (lastChar === "%") return parseFloat(val) / 100 * percentRef;

    return parseFloat(val);
}

export function unitize(val: string | number, unit: string): string {
    if (isString(val)) return val;
    return val + unit;
}

export function cssPoint(left: string | number, top: string | number): string {
    return unitize(left, "px") + " " + unitize(top, "px");
}

export function parentPath(path: string): string {
    if (path[path.length - 1] === "/") path = path.slice(0, -1);
    const parts = path.split("/"); parts.pop();
    return parts.join("/");
}

export function standardizePath(path: string): string {
    path = path.trim().replace("\\", "/").replace(/([^:]\/)\/+/g, "$1");
    if (path.includes("file:///")) path = path.replace("file://", "file:///");
    if (path[path.length - 1] === "/") path = path.slice(0, -1);
    return path;
}

export function between(source: string, a: string | number, b: string | number, start = 0): string {
    let iA = -1;
    if (isNumber(a)) iA = a;
    else {
        iA = source.indexOf(a, start);
        if (iA !== -1) iA += a.length - 1;
    }
    if (iA === -1) return "";

    const iB = isNumber(b) ? b : source.indexOf(b, iA);
    if (iB === -1) return "";

    return source.substring(a.constructor === Number ? iA : iA + 1, iB);
}

export function replaceAll(str: string, search: string, replacement: string): string {
    return str.split(search).join(replacement);
}

export function indexesOf(source: string, search: string): Array<number> {
    const a = [];
    let i = -1;
    while ((i = source.indexOf(search, i + 1)) >= 0)
        a.push(i);
    return a;
}

export function indexesBefore(source: string, search: string, length: number): Array<number> {
    const result = [], firstChar = search[0];
    let lastPos = 0;

    for (let i = 0; i < source.length; ++i) {
        if (i - lastPos >= length) break;
        if (source[i] !== firstChar) continue;

        let count = 0, found = true;
        const jMax = search.length + i;
        for (let j = i; j < jMax; ++j) {
            if (source[j] !== search[count]) {
                found = false;
                break;
            }
            ++count;
        }
        if (found) result.push(i), lastPos = i;
    }

    return result;
}

export function extension(path: string): string {
    const parts = path.split(".");
    if (parts.length > 1) return (parts.pop() as string).toLowerCase();
    return "";
}

export function kebabCase(str: string): string {
    let result = "", isNumOld = false;
    for (const char of str) {
        const isNum = numbers[char] === true;
        const lower = char.toLowerCase();

        if (char !== lower) {
            if (result !== "") result += "-" + lower;
            else result = lower;
        }
        else if (isNum !== isNumOld) result += "-" + lower;
        else result += char;

        isNumOld = isNum;
    }
    return result;
}

const kebabed = new Map<string, string>();
export function fastKebabCase(text: string): string {
    return forceGet(kebabed, text, () => kebabCase(text));
}

export function camelCase(str: string): string {
    str = str.replace(/[-_\s]+(.)?/g, (match, ch) => (ch ? ch.toUpperCase() : ""));
    return str.substr(0, 1).toLowerCase() + str.substr(1);
}

const cameled = new Map<string, string>();
export function fastCamelCase(text: string): string {
    return forceGet(cameled, text, () => camelCase(text));
}

export function upperFirst(str: string): string {
    return str[0].toUpperCase() + str.slice(1);
}

export function lowerFirst(str: string): string {
    return str[0].toLowerCase() + str.slice(1);
}

export function extend<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U> {
    for (const key of Object.keys(src)) dst[key] = src[key];
    return dst;
}

export function extendNull<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U> {
    for (const key of Object.keys(src))
        if (dst[key] == null)
            dst[key] = src[key];
    return dst;
}

export function mergeArrays<A, T>(dst: Array<A | T>, src: Array<T>): Array<A | T> {
    let max: Array<T | A>, min: Array<T | A>;
    if (src.length > dst.length) max = src, min = dst;
    else max = dst, min = src;

    for (let key = 0; key < min.length; ++key) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject<{}>(srcVal) && isObject<{}>(dstVal)) merge(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal)) mergeArrays(dstVal, srcVal);
        else dst[key] = srcVal as any;
    }
    for (let i = min.length; i < max.length; ++i) dst[i] = max[i];
    return dst;
}

export function mergeArraysNull<A, T>(dst: Array<A | T>, src: Array<T>): Array<A | T> {
    let max: Array<A | T>, min: Array<A | T>;
    if (src.length > dst.length) max = src, min = dst;
    else max = dst, min = src;

    for (let key = 0; key < min.length; ++key) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject<{}>(srcVal) && isObject<{}>(dstVal)) mergeNull(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal)) mergeArraysNull(dstVal, srcVal);
        else if (dstVal == null) dst[key] = srcVal as any;
    }
    for (let i = min.length; i < max.length; ++i) dst[i] = max[i];
    return dst;
}

export function merge<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U> {
    for (const key of Object.keys(src)) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject<{}>(srcVal) && isObject<{}>(dstVal)) merge(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal)) mergeArrays(dstVal, srcVal);
        else dst[key] = srcVal;
    }
    return dst;
}

export function mergeNull<T, U>(dst: Obj<T | U>, src: Obj<U>): Obj<T | U> {
    for (const key of Object.keys(src)) {
        const dstVal = dst[key], srcVal = src[key];
        if (isObject<{}>(srcVal) && isObject<{}>(dstVal)) mergeNull(dstVal, srcVal);
        else if (isArray(srcVal) && isArray(dstVal)) mergeArraysNull(dstVal, srcVal);
        else if (dstVal == null) dst[key] = srcVal;
    }
    return dst;
}

export function cloneDeep<T extends Obj<any> | Array<any>>(src: T): T {
    if (isObjectNotFunction(src)) {
        const r: Obj<any> = {};
        forOwn(src, (v, k) => r[k] = cloneDeep(v as any));
        return r as T;
    }
    if (isArray(src)) {
        const length = src.length;
        const r: Array<any> = new Array(length);
        for (let i = 0; i < length; ++i) r[i] = cloneDeep(src[i] as any);
        return r as T;
    }
    return src;
}

export function someOwn<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => any): boolean {
    for (const key of Object.keys(o))
        if (cb(o[key], key))
            return true;
    return false;
}

export function forOwn<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => void): void {
    for (const key of Object.keys(o))
        cb(o[key], key);
}

export function forOwnDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string, owner: Obj<any>) => void): void {
    forOwn(o, (value, key) => {
        if (isObject(value))
            forOwnDeep(value, cb);
        cb(value, key, o);
    });
}

export function reduce<T, P extends Obj<any>>(o: P, cb: (r: T, v: valueof<P>, k: string) => T, initial: T): T {
    let res = initial;
    forOwn(o, (v, k) => res = cb(res, v, k));
    return res;
}

export function omit(o: Obj<any>, key: string): Obj<any>;
export function omit(o: Obj<any>, keys: Array<string>): Obj<any>;
export function omit(o: Obj<any>, arg1: string | Array<string>): Obj<any> {
    if (isArray(arg1)) return reduce(o, (r, v, k) => {
        if (!arg1.includes(k)) r[k] = v;
        return r;
    }, {} as Obj<any>);

    return reduce(o, (r, v, k) => {
        if (k !== arg1) r[k] = v;
        return r;
    }, {} as Obj<any>);
}

export function omitDeep(o: Obj<any>, key: string): Obj<any>;
export function omitDeep(o: Obj<any>, keys: Array<string>): Obj<any>;
export function omitDeep(o: Obj<any>, arg1: string | Array<string>): Obj<any> {
    if (isArray(arg1)) return reduce(o, (r, v, k) => {
        if (!arg1.includes(k)) r[k] = isObject(v) ? omitDeep(v, arg1) : v;
        return r;
    }, {} as Obj<any>);

    return reduce(o, (r, v, k) => {
        if (k !== arg1) r[k] = isObject(v) ? omitDeep(v, arg1) : v;
        return r;
    }, {} as Obj<any>);
}

export function replaceKeys<T extends Obj<any>>(o: T, map: Obj<string>): Obj<any> {
    return reduce(o, (r, v, k) => {
        r[map[k] || k] = v;
        return r;
    }, {} as Obj<any>);
}

export function replaceKeysDeep<T extends Obj<any>>(o: T, map: Obj<string>): Obj<any> {
    return reduce(o, (r, v, k) => {
        r[map[k] || k] = isObject(v) ? replaceKeysDeep(v, map) : v;
        return r;
    }, {} as Obj<any>);
}

export function mapValues<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => valueof<T>): T {
    return reduce(o, (r, v, k) => {
        r[k] = cb(v, k);
        return r;
    }, {} as T);
}

export function mapValuesDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => valueof<T>): Obj<any> {
    return reduce(o, (r, v, k) => {
        //@ts-ignore
        r[k] = cb(isObject(v) ? mapValuesDeep(v, cb) : v, k);
        return r;
    }, {} as Obj<any>);
}

export function mapKeys<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => string): Obj<any> {
    return reduce(o, (r, v, k) => {
        r[cb(v, k)] = v;
        return r;
    }, {} as Obj<any>);
}

export function mapKeysDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => string): Obj<any> {
    return reduce(o, (r, v, k) => {
        r[cb(v, k)] = isObject(v) ? mapKeysDeep(v, cb) : v;
        return r;
    }, {} as Obj<any>);
}

export function filterKeys<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => boolean): Array<string> {
    return reduce(o, (r, v, k) => {
        if (cb(v, k)) r.push(k);
        return r;
    }, [] as Array<string>);
}

export function filterKeysDeep<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => boolean): Array<string> {
    return reduce(o, (r, v, k) => {
        if (isObject(v)) for (const _k of filterKeysDeep(v, cb)) r.push(_k);
        if (cb(v, k)) r.push(k);
        return r;
    }, [] as Array<string>);
}

export function sortByKeys<T>(o: Obj<T>, order: Array<string>): Obj<T> {
    const r: any = {};
    for (const k of order) {
        if (k in o) r[k] = o[k];
    }
    return extendNull(r, o);
}

export function reverse<T>(o: Obj<T>): Obj<T> {
    return sortByKeys(o, Object.keys(o).reverse());
}

export function pickBy<T extends Obj<any>>(o: T, cb: (v: valueof<T>, k: string) => any): Obj<any> {
    const result: Obj<any> = {};
    forOwn(o, (v, k) => { if (cb(v, k)) result[k] = v });
    return result;
}

export function values<T>(o: Obj<T>): Array<T> {
    const result: Array<T> = [];
    forOwn(o, v => result.push(v));
    return result;
}

export function size(o: Obj<any>): number {
    return Object.keys(o).length;
}

export function entries<T>(o: Obj<T>): Array<[string, T]> {
    const result: Array<[string, T]> = [];
    forOwn(o, (v, k) => result.push([k, v]));
    return result;
}

export function fromPairs<T>(array: Array<[string, T]>): Obj<T> {
    const result: Obj<T> = {};
    for (const pair of array) result[pair[0]] = pair[1];
    return result;
}

export function forEach<T>(array: ArrayLike<T>, cb: (item: T, index: number) => void): void {
    const a = new Array(array.length);
    for (let i = 0; i < array.length; ++i) a[i] = array[i];
    for (let i = 0; i < a.length; ++i) cb(a[i], i);
}

export function pushOne<T>(array: Array<T>, item: T): boolean {
    if (array.includes(item)) return false;
    array.push(item);
    return true;
}

export function pullOne<T>(array: Array<T>, item: T): boolean {
    const index = array.indexOf(item);
    if (index === -1) return false;
    array.splice(index, 1);
    return true;
}

export function pullOneBy<T>(array: Array<T>, predicate: (val: T) => boolean): boolean {
    for (const item of array)
        if (predicate(item)) {
            pullOne(array, item);
            return true;
        }
    return false;
}

export function last<T>(array: ArrayLike<T>, count?: number): T | undefined;
export function last<T>(array: ArrayLike<T>, count: number, defaultVal: T): T;
export function last<T>(array: ArrayLike<T>, count = 0, defaultVal?: T): T | undefined {
    const index = array.length - (count + 1);
    if (index < 0) {
        if (defaultVal != null)
            return defaultVal;
        else
            return array[0];
    }
    return array[index];
}

const arraySetMap = new WeakMap<Array<any>, WeakSet<any>>();

export class ArraySet<T extends object> {
    private array: Array<T>;
    private set: WeakSet<T>;

    constructor(array: Array<T>) {
        if (arraySetMap.has(array))
            this.set = arraySetMap.get(array)!;
        else {
            this.set = new WeakSet();
            arraySetMap.set(array, this.set);
            for (const item of array)
                this.set.add(item);
        }
        this.array = array;
    }

    public add(val: T): void {
        if (this.set.has(val)) return;
        this.set.add(val);
        this.array.push(val);
    }

    public delete(val: T): void {
        if (!this.set.has(val)) return;
        this.set.delete(val);
        pullOne(this.array, val);
    }

    public clear(): void {
        for (const item of this.array)
            this.set.delete(item);

        clear(this.array);
    }

    public has(val: T): boolean {
        return this.set.has(val);
    }
}

export function defaultTo<T>(val: T, defaultVal: T): T {
    if (!val && (val as any) !== "" && (val as any) !== 0) return defaultVal;
    else return val;
}

//@ts-ignore
export function coalesce<T>(items: Array<T>): T {
    for (const i of items)
        if (i != null) return i;
}

export function get<T = any>(item: any, path: string): T | undefined;
export function get<T = any>(item: any, path: string, defaultVal: T): T;
export function get<T = any>(item: any, path: string, defaultVal?: T): T | undefined {
    for (const part of path.split(".")) {
        item = item[part];
        if (item == null) return defaultVal;
    }
    return item;
}

export function call(item: any, path: string, args: Array<any>, force = false): any {
    let parent: any;
    for (const part of path.split(".")) {
        parent = item;
        item = item[part];
        if (item == null) {
            if (!force) return;
            throw new Error('invalid function');
        }
    }
    if (!isFunction(item)) {
        if (!force) return;
        throw new Error('invalid function');
    }
    return item.apply(parent, args);
}

export function now(): number {
    return (new Date()).getTime();
}

function time2Step(timeStr: string, stepSize: number): number {
    const parts = timeStr.split(":"), minutesStr = parts[1], hoursStr = parts[0];
    const minutes = parseFloat(minutesStr), hours = parseFloat(hoursStr);
    const totalHours = hours + (minutes / 60), totalMinutes = totalHours * 60;
    return totalMinutes / stepSize;
}

export function hours(beginTime: string = "00:00", endTime: string = "23:59", division: number = 2) {
    const stepSize = 60 / division, stepCount = 24 * division;
    const beginStep = time2Step(beginTime, stepSize), endStep = time2Step(endTime, stepSize);

    const result = [];
    for (let step = 0; step <= stepCount; ++step) {
        if (step < beginStep || step > endStep) continue;
        const totalMinutes = step * stepSize, totalHours = totalMinutes / 60;
        const hours = Math.floor(totalHours), minutes = Math.floor((totalHours - hours) * 60);

        let hoursStr = "" + hours;
        if (hoursStr.length === 1) hoursStr = "0" + hoursStr;

        let minutesStr = "" + minutes;
        if (minutesStr.length === 1) minutesStr = "0" + minutesStr;

        result.push(hoursStr + ":" + minutesStr);
    }
    return result;
}

export function range(end: number): Array<number>;
export function range(start: number, end: number, step?: number): Array<number>;
export function range(start: number, end?: number, step = 1): Array<number> {
    step = Math.abs(step);
    if (end == null) {
        end = start;
        start = 0;
    }
    const r: Array<number> = [];
    if (end >= start)
        for (let i = start; i < end; i += step)
            r.push(i);
    else
        for (let i = start; i > end; i -= step)
            r.push(i);
    return r;
}

export function randomColor(): string {
    const letters = "0123456789ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; ++i) color += letters[Math.floor(Math.random() * 16)];
    return color;
}

export function concatOne(src: string | nil, str: string, prepend = false, delimiter = " "): string {
    if (!src) return str;
    const parts = src.split(delimiter);
    if (parts.includes(str)) return src;
    prepend ? parts.unshift(str) : parts.push(str);
    return parts.join(delimiter);
}

export function splitOutside(val: string, delimiter: string, leftSymbol: string, rightSymbol: string) {
    const tmp = val.split(delimiter);
    const result: Array<string> = [];
    for (let i = 0, j = 0; i < tmp.length; ++i) {
        result[j] = (result[j] != null ? result[j] + delimiter : "") + tmp[i];
        if (!result[j].includes(leftSymbol) || result[j].includes(rightSymbol))
            j++;
    }
    return result;
}

export function random(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

export function leadingDebounce<T extends Function>(cb: T, promiseFactory: () => Promise<any>): T;
export function leadingDebounce<T extends Function>(cb: T, duration?: number): T;
export function leadingDebounce<T extends Function>(cb: T, arg1: (() => Promise<any>) | number = 0): T {
    let blocked = false, result: any;
    return function (this: any) {
        if (blocked) return result;
        blocked = true, result = cb.apply(this, arguments);
        if (isNumber(arg1)) setTimeout(() => blocked = false, arg1);
        else arg1().then(() => blocked = false);
        return result;
    } as any;
}

export function mergeFunctions<T extends Function | nil>(dst: T, src: Exclude<T, nil>): T {
    if (dst == null) return src as any;
    return function(this: any) {
        src.apply(this, arguments);
        return dst.apply(this, arguments);
    } as any;
}

function clearProto(o: Obj<any>) {
    const obj = JSON.parse(JSON.stringify(o));
    if (obj && typeof obj === "object") {
        obj.__proto__ = null;
        for (const j in obj) obj[j] = clearProto(obj[j]);
    }
    return obj;
}

export function log(...args: Array<any>) {
    for (let i = 0; i < args.length; ++i) args[i] = clearProto(args[i]);
    console.log(...args);
}

export class Queue implements PromiseLike<void> {
    private resolvables: Array<Resolvable> = [new Resolvable().resolve()];

    public then(cb: Callback<void>): this;
    public then(cb: Callback<void>): this;
    public then(cb: Callback<void>): this {
        this.resolvables[this.resolvables.length - 1].then(cb);
        const r = new Resolvable(() => { pullOne(this.resolvables, r) });
        this.resolvables.push(r);
        return this;
    }

    public resolve(): this {
        if (this.resolvables.length === 1) return this;
        this.resolvables[1].resolve();
        return this;
    }
}

abstract class Thenable<T> implements PromiseLike<T> {
    protected _done = false;
    private _value: T | null = null;
    private _callbacks: Array<Callback<T>> = [];
    private _watched: Array<Thenable<T>> = [];
    private _cb: Callback<T> | null = null;

    public constructor(cb?: Callback<T>) {
        if (cb != null) this._cb = cb;
    }

    public then(cb: Callback<T>): Cancellable;
    public then(cb: Callback<T>): Cancellable;
    public then(cb: Callback<T>): Cancellable {
        if (this._done) {
            if (this._value === null)
                throw new Error("unexpected value");

            cb(this._value);
            return new Cancellable();
        }
        else {
            this._callbacks.push(cb);
            return new Cancellable(() => pullOne(this._callbacks, cb));
        }
    }

    public watch<U extends Thenable<any>>(item: U): U {
        if (this._done) return item._resolve(this._value);
        this._watched.push(item);
        item.then(() => pullOne(this._watched, item));
        return item;
    }

    protected _resolve(val: T): this {
        if (this._done) return this;
        this._done = true;
        this._value = val;

        if (this._cb != null) this._cb(val);
        this._cb = null;

        for (const cb of [...this._callbacks]) cb(val);
        this._callbacks = [];

        for (const item of [...this._watched]) item._resolve(val);
        this._watched = [];

        return this;
    }
}

export class Resolvable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb);
    }

    public get resolved(): boolean {
        return this._done;
    }

    public resolve(val: T): this {
        return this._resolve(val);
    }
}

export class Cancellable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb);
    }

    public get cancelled(): boolean {
        return this._done;
    }

    public cancel(val: T): this {
        return super._resolve(val);
    }
}

export class Playable<T = void> extends Thenable<T> {
    public paused = true;

    public constructor(autoplay = false) {
        super();
        if (autoplay) this.paused = false;
    }

    public get stopped(): boolean {
        return this._done;
    }

    public stop(val: T): this {
        return super._resolve(val);
    }

    private pauseCbs: Array<Callback<void>> = [];
    private playCbs: Array<Callback<void>> = [];

    public onPause(cb: Callback<void>): Cancellable {
        if (this._done) return new Cancellable();

        if (this.paused) cb();

        this.pauseCbs.push(cb);
        return new Cancellable(() => pullOne(this.pauseCbs, cb));
    }

    public onPlay(cb: Callback<void>): Cancellable {
        if (this._done) return new Cancellable();

        if (!this.paused) cb();

        this.playCbs.push(cb);
        return new Cancellable(() => pullOne(this.playCbs, cb));
    }

    public pause(): this {
        if (this._done || this.paused) return this;
        this.paused = true;
        for (const cb of this.pauseCbs) cb();
        return this;
    }

    public play(): this {
        if (this._done || !this.paused) return this;
        this.paused = false;
        for (const cb of this.playCbs) cb();
        return this;
    }
}

export class Destroyable<T = void> extends Thenable<T> {
    public constructor(cb?: Callback<T>) {
        super(cb);
    }

    public get destroyed(): boolean {
        return this._done;
    }

    public destroy(val: T): this {
        return super._resolve(val);
    }
}

export class Value<T = any> extends Destroyable {
    private cbs: Array<Callback<T>> = [];
    //@ts-ignore
    private state: T;
    private hasState = false;

    public constructor(value?: T) {
        super(() => {
            this.cbs = [];
            //@ts-ignore
            this.state = undefined;
            this.hasState = false;
        });
        if (value != null)
            this.set(value);
    }

    public on(cb: Callback<T>): Cancellable {
        if (this.hasState)
            cb(this.state);

        this.cbs.push(cb);
        return new Cancellable(() => pullOne(this.cbs, cb));
    }

    public once(cb: Callback<T>): Cancellable {
        let done = false;
        const handle = this.on(value => {
            if (done) return;
            done = true;

            cb(value);
            setTimeout(() => handle.cancel(), 0);
        });
        return handle;
    }

    public set(value: T): this {
        if (value === this.state)
            return this;

        this.state = value;
        this.hasState = true;

        for (const cb of this.cbs)
            cb(value);

        return this;
    }
}

export class Events<T = any, U extends string = any> extends Destroyable {
    private cbsMap = new Map<string, Array<Callback<T>>>();
    private states = new Map<string, T>();

    public constructor() {
        super(() => {
            this.cbsMap.clear();
            this.states.clear();
        });
    }

    public on(name: U | Array<U>, cb: Callback<T>): Cancellable {
        if (isArray(name)) {
            const handle = new Cancellable();
            for (const n of name) handle.watch(this.on(n, cb));
            return handle;
        }
        if (this.states.has(name))
            cb(this.states.get(name) as T);

        const cbs = forceGet(this.cbsMap, name, () => []);
        cbs.push(cb);
        return new Cancellable(() => pullOne(cbs, cb));
    }
    
    public once(name: U | Array<U>, cb: Callback<T>): Cancellable {
        let done = false;
        const handle = this.on(name, value => {
            if (done) return;
            done = true;
            
            cb(value);
            setTimeout(() => handle.cancel(), 0);
        });
        return handle;
    }

    public emit(name: U, value: T): void {
        const cbs = this.cbsMap.get(name);
        if (cbs != null)
            for (const cb of cbs) cb(value);
    }

    public hasState(name: U): boolean {
        return this.states.has(name);
    }

    public setState(name: U, value: T): void {
        this.states.set(name, value);
        this.emit(name, value);
    }

    public getState(name: U): T | undefined {
        return this.states.get(name);
    }

    public deleteState(name: U): void {
        this.states.delete(name);
    }

    public interval(cb: Callback<any>, delay: number): Cancellable {
        return this.watch(interval(cb, delay));
    }
    
    public timeout(cb: Callback<any>, delay: number): Cancellable {
        return this.watch(timeout(cb, delay));
    }
    
    public nextFrame(cb: Callback<any>): Cancellable {
        return this.watch(nextFrame(cb));
    }

    public nextTick(cb: Callback<any>): Cancellable {
        return this.watch(nextTick(cb));
    }

    public endOfTick(cb: Callback<any>): Cancellable {
        return this.watch(endOfTick(cb));
    }

    public nextDelay(cb: Callback<any>): Cancellable {
        return this.watch(nextDelay(cb));
    }

    public nthDelay(cb: Callback<any>, n: number): Cancellable {
        return this.watch(nthDelay(cb, n));
    }

    public frameLoop(cb: (deltaTime: number, time: number) => void): Cancellable {
        return this.watch(frameLoop(cb));
    }
}

export class DomEvents extends Events {
    private el: Node;
    private listening = new Set<string>();

    public constructor(el: Node, name?: string | Array<string>) {
        super();
        this.el = el;
        if (name != null) this.listen(name);
    }

    public listen(name: string | Array<string>): this {
        if (isArray(name)) {
            for (const n of name) this.listen(n);
            return this;
        }
        if (this.listening.has(name)) return this;
        this.listening.add(name);

        const cb = (e: any) => this.emit(name, e);
        this.el.addEventListener(name, cb);
        this.then(() => this.el.removeEventListener(name, cb));

        return this;
    }
}

export function interval(cb: Callback<any>, delay: number): Cancellable {
    const interval = setInterval(cb, delay);
    return new Cancellable(() => clearInterval(interval));
}

export function timeout(cb: Callback<any>, delay: number): Cancellable {
    const timeout = setTimeout(cb, delay);
    return new Cancellable(() => clearTimeout(timeout));
}

export function nextFrame(cb: Callback<any>): Cancellable {
    const handle = new Cancellable();
    requestAnimationFrame(() => {
        //@ts-ignore
        if (!handle.cancelled) cb();
    });
    return handle;
}

export function nextTick(cb: Callback<any>): Cancellable {
    return timeout(cb, 0);
}

export function endOfTick(cb: Callback<any>): Cancellable {
    const handle = new Cancellable();
    Promise.resolve().then(() => {
        //@ts-ignore
        if (!handle.cancelled) cb();
    });
    return handle;
}

export function nextDelay(cb: Callback<any>): Cancellable {
    const handle = new Cancellable();
    setTimeout(() => requestAnimationFrame(() => requestAnimationFrame(() => {
        //@ts-ignore
        if (!handle.cancelled) cb();
    })), 0);
    return handle;
}

export function nthDelay(cb: Callback<any>, n: number): Cancellable {
    const handle = new Cancellable();

    (async() => {
        for (let i = 0; i < n; ++i) {
            await new Promise(r => nextDelay(r));
            if (handle.cancelled) return;
        }
        //@ts-ignore
        cb();
    })();

    return handle;
}

export function frameLoop(cb: (deltaTime: number, time: number) => void): Cancellable {
    const handle = new Cancellable();
    let start = -1;
    function fn(time: number) {
        if (handle.cancelled) return;
        if (start === -1) start = time;
        cb(time - start, time);
        requestAnimationFrame(fn);
    };
    requestAnimationFrame(fn);
    return handle;
}

export function drawDiv(left: number, top: number, parent: Node = document.body): HTMLElement {
    const v = parent.appendChild(document.createElement("div"));
    v.style.transform = "translateX(-50%) translateY(-50%)";
    v.style.width = "5px";
    v.style.height = "5px";
    v.style.background = randomColor();
    v.style.position = "absolute";
    v.style.left = left + "px";
    v.style.top = top + "px";
    v.style.zIndex = "9999";
    return v;
}

export function loadImage(src: string | HTMLImageElement): Promise<HTMLImageElement> {
    return new Promise<HTMLImageElement>(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        if (isString(src)) img.src = src;
        else img.src = src.src;
    });
}

export function naturalSize(image: HTMLImageElement): Promise<{ width: number, height: number }> {
    return new Promise(resolve => {
        if (image.naturalWidth && image.naturalHeight) {
            resolve({ width: image.naturalWidth, height: image.naturalHeight });
            return;
        }
        const handle = interval(() => {
            if (!document.body.contains(image)) {
                handle.cancel();
                return;
            }
            if (!(image.naturalWidth && image.naturalHeight)) return;
            handle.cancel();
            resolve({ width: image.naturalWidth, height: image.naturalHeight });
        }, 0);
    })
}

export function clientSize(el: Node): Promise<{ width: number, height: number }> {
    return new Promise(resolve => {
        if ((el as any).clientWidth && (el as any).clientHeight) {
            resolve({ width: (el as any).clientWidth, height: (el as any).clientHeight });
            return;
        }
        const handle = interval(() => {
            if (!document.body.contains(el)) {
                handle.cancel();
                return;
            }
            if (!((el as any).clientWidth && (el as any).clientHeight)) return;
            handle.cancel();
            resolve({ width: (el as any).clientWidth, height: (el as any).clientHeight });
        }, 0);
    })
}

export function remove<T extends Node>(el: T): T {
    if (el.parentElement != null)
        el.parentElement.removeChild(el);
    return el;
}

export function addClass<T extends Node>(el: T, name: string, prepend = false): T {
    (el as any).className = concatOne((el as any).className, name, prepend);
    return el;
}

let htmlDiv: HTMLElement | undefined;
export function html<T extends HTMLElement>(html: string): T {
    if (htmlDiv == null)
        htmlDiv = document.createElement("div");

    htmlDiv.innerHTML = html;
    const res = htmlDiv.firstElementChild;

    if (res == null)
        throw new Error("invalid html");
        
    return res as T;
}

export function vif<T>(bool: boolean, res: T): T | undefined {
    return bool ? res : undefined;
}