import { pullOne, isArray, now, isString, Cancellable, frameLoop, forceGet } from "ambients-utils";
const fromMap = new WeakMap();
const persistentMap = new WeakMap();
export class Eventss {
    constructor() {
        this.eventMap = {};
        this.stateValue = {};
        this.stateEmitted = {};
        this.debounceMap = {};
        this.emitDebounceMap = {};
        this.emitDebounceValueMap = {};
        this.timeMap = {};
        this.loop = false;
    }
    off(name) {
        const arr = this.eventMap[name];
        if (arr == undefined)
            return this;
        for (const cb of [...arr])
            if (!persistentMap.has(cb))
                pullOne(arr, cb);
        return this;
    }
    on(name, cb, persistent = false) {
        if (isArray(name)) {
            const handle = new Cancellable();
            for (const _name of name)
                handle.watch(this.on(_name, cb, persistent));
            return handle;
        }
        if (name === 'immediate') {
            cb(this.stateValue[name]);
            return new Cancellable();
        }
        if (this.stateEmitted[name] === true)
            cb(this.stateValue[name]);
        const events = (this.eventMap[name] || (this.eventMap[name] = []));
        if (persistent)
            persistentMap.set(cb, true);
        events.push(cb);
        return new Cancellable(() => pullOne(events, cb));
    }
    once(name, cb, persistent = false) {
        const handle = new Cancellable();
        handle.watch(this.on(name, value => {
            handle.cancel(), cb(value);
        }, persistent));
        return handle;
    }
    emit(name, value, force = false) {
        if (!force) {
            const duration = this.debounceMap[name];
            if (duration != undefined)
                return this.emitDebounce(duration, name, value);
        }
        const events = this.eventMap[name];
        if (events == undefined)
            return this;
        for (const cb of [...events])
            cb(value);
        return this;
    }
    emitState(name, value) {
        this.stateValue[name] = value;
        this.stateEmitted[name] = true;
        this.emit(name, value);
        return this;
    }
    cancelState(name) {
        this.stateValue[name] = undefined;
        this.stateEmitted[name] = false;
        return this;
    }
    ;
    emitDebounce(duration, name, value) {
        this.emitDebounceValueMap[name] = value;
        if (this.emitDebounceMap[name] !== true) {
            this.emitDebounceMap[name] = true;
            setTimeout(() => {
                this.emit(name, this.emitDebounceValueMap[name], true);
                this.emitDebounceMap[name] = false;
            }, duration);
        }
        return this;
    }
    emitLeadingDebounce(duration, name, value) {
        const newTime = now();
        if (newTime - (this.timeMap[name] || 0) >= duration) {
            this.emit(name, value, true);
            this.timeMap[name] = newTime;
        }
        return this;
    }
    debounce(name, duration) {
        this.debounceMap[name] = duration;
        return this;
    }
    reset() {
        this.emit('reset');
        this.eventMap = {};
        this.timeMap = {};
        this.stateValue = {};
        this.stateEmitted = {};
        return this;
    }
    from(arg0, arg1, arg2) {
        if (isString(arg0)) {
            const name = arg0;
            const newName = arg1;
            if (name === 'frameLoop') {
                if (this.loop === true)
                    return this;
                this.loop = true;
                const handle = frameLoop(() => this.emit(newName || name));
                this.once('reset', () => {
                    handle.cancel();
                    this.loop = false;
                }, true);
            }
            return this;
        }
        const el = (arg0 === document.body && arg1 === 'scroll') ? document : arg0;
        const name = arg1;
        const newName = arg2;
        if (isArray(name)) {
            for (const _name of name)
                this.from(el, _name, newName);
            return this;
        }
        let elMap = forceGet(forceGet(fromMap, this, () => new WeakMap()), el, () => { return {}; });
        if (elMap[name] === true)
            return this;
        elMap[name] = true;
        if ('addEventListener' in el) {
            const emit = (e) => this.emit(newName || name, e);
            el.addEventListener(name, emit);
            this.once('reset', () => {
                el.removeEventListener(name, emit);
                elMap[name] = false;
            }, true);
        }
        else {
            const handle = el.on('name', e => this.emit(newName || name, e), true);
            this.once('reset', () => handle.cancel(), true);
        }
        return this;
    }
}
