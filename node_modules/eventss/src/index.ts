import { pullOne, Obj, isArray, now, isString, Cancellable, Callback, frameLoop, forceGet } from "ambients-utils";

type DOMElement = Element | Window | Document;

const fromMap = new WeakMap<Eventss<any>, WeakMap<DOMElement | Eventss<any>, Obj<boolean>>>();
const persistentMap = new WeakMap<Function, boolean>();

export class Eventss<T> {
    private eventMap:Obj<Array<Callback<T | undefined>>> = {};
    private stateValue: Obj<any> = {};
    private stateEmitted: Obj<boolean> = {};
    private debounceMap:Obj<number> = {};

    public off(name:string):this {
        const arr = this.eventMap[name];
        if (arr == undefined) return this;
        for (const cb of [...arr]) if (!persistentMap.has(cb)) pullOne(arr, cb);
        return this;
    }
    
    public on(name:Array<string> | string, cb:Callback<T | undefined>, persistent = false):Cancellable {
        if (isArray(name)) {
            const handle = new Cancellable();
            for (const _name of name) handle.watch(this.on(_name, cb, persistent));
            return handle;
        }
        if (name === 'immediate') {
            cb(this.stateValue[name]);
            return new Cancellable();
        }
        if (this.stateEmitted[name] === true) cb(this.stateValue[name]);

        const events = (this.eventMap[name] || (this.eventMap[name] = []));
        if (persistent) persistentMap.set(cb, true);
        events.push(cb);
        return new Cancellable(() => pullOne(events, cb));
    }

    public once(name: string | Array<string>, cb: Callback<T | undefined>, persistent = false): Cancellable {
        const handle = new Cancellable();
        handle.watch(this.on(name, value => {
            handle.cancel(), cb(value);
        }, persistent));
        return handle;
    }

    public emit(name:string, value?:T, force = false):this {
        if (!force) {
            const duration = this.debounceMap[name];
            if (duration != undefined) return this.emitDebounce(duration, name, value);
        }
        const events = this.eventMap[name];
        if (events == undefined) return this;
        for (const cb of [...events]) cb(value);
        return this;
    }

    public emitState(name:string, value?:T):this {
        this.stateValue[name] = value;
        this.stateEmitted[name] = true;
        this.emit(name, value);
        return this;
    }

    public cancelState(name:string):this {
        this.stateValue[name] = undefined;
        this.stateEmitted[name] = false;
        return this;
    };

    private emitDebounceMap:Obj<boolean> = {};
    private emitDebounceValueMap:Obj<T | undefined> = {};

    public emitDebounce(duration:number, name:string, value?:T):this {
        this.emitDebounceValueMap[name] = value;
        if (this.emitDebounceMap[name] !== true) {
            this.emitDebounceMap[name] = true;
            setTimeout(() => {
                this.emit(name, this.emitDebounceValueMap[name], true);
                this.emitDebounceMap[name] = false;
            }, duration);
        }
        return this;
    }

    private timeMap:Obj<number> = {};

    public emitLeadingDebounce(duration: number, name: string, value?: T): this {
        const newTime = now();
        if (newTime - (this.timeMap[name] || 0) >= duration) {
            this.emit(name, value, true);
            this.timeMap[name] = newTime;
        }
        return this;
    }

    public debounce(name:string, duration:number):this {
        this.debounceMap[name] = duration;
        return this;
    }

    public reset():this {
        this.emit('reset');
        this.eventMap = {};
        this.timeMap = {};
        this.stateValue = {};
        this.stateEmitted = {};
        return this;
    }

    private loop = false;

    public from(name: string, newName?: string):this;
    public from(el:DOMElement | Eventss<any>, name:string | Array<string>, newName?:string):this;
    public from(arg0:any, arg1?:any, arg2?:any):this {
        if (isString(arg0)) {
            const name: string = arg0;
            const newName: string = arg1;

            if (name === 'frameLoop') {
                if (this.loop === true) return this;
                this.loop = true;

                const handle = frameLoop(() => this.emit(newName || name));
                this.once('reset', () => {
                    handle.cancel();
                    this.loop = false;
                }, true);
            }
            return this;
        }
        const el: DOMElement | Eventss<any> = (arg0 === document.body && arg1 === 'scroll') ? document : arg0;
        const name: string | Array<string> = arg1;
        const newName: string = arg2;
        
        if (isArray(name)) {
            for (const _name of name) this.from(el, _name, newName);
            return this;
        }
        let elMap = forceGet(forceGet(fromMap, this, () => new WeakMap()), el, () => { return {} as Obj<boolean> });
        if (elMap[name] === true) return this;
        elMap[name] = true;

        if ('addEventListener' in el) {
            const emit = (e:T) => this.emit(newName || name, e);
            el.addEventListener(name, emit as any);
            this.once('reset', ()=>{ 
                el.removeEventListener(name, emit as any);
                elMap[name] = false;
            }, true);
        }
        else {
            const handle = el.on('name', e=>this.emit(newName || name, e), true);
            this.once('reset', ()=>handle.cancel(), true);
        }
        return this;
    }
}